// Advanced Carv features - classes, result types, maps, string interpolation

// String interpolation
let name = "Carv";
let version = "0.1.0";
println(f"Welcome to {name} v{version}!");

let x = 42;
let y = 3.14;
println(f"The answer is {x} and pi is approximately {y}");

// Expressions in interpolation
let a = 10;
let b = 5;
println(f"{a} + {b} = {a + b}");
println(f"{a} * {b} = {a * b}");

// Classes
class Counter {
    value: int = 0

    fn increment() {
        self.value = self.value + 1;
    }

    fn get() -> int {
        return self.value;
    }
}

let counter = new Counter;
counter.increment();
counter.increment();
println(f"counter value: {counter.get()}");

// Result types and pattern matching
fn divide(a: int, b: int) {
    if b == 0 {
        return Err("division by zero");
    }
    return Ok(a / b);
}

let result = divide(10, 2);
match result {
    Ok(v) => println(f"10 / 2 = {v}"),
    Err(e) => println(f"error: {e}"),
};

let bad = divide(10, 0);
match bad {
    Ok(v) => println(f"result: {v}"),
    Err(e) => println(f"caught error: {e}"),
};

// Try operator
fn calculate() {
    let x = divide(100, 5)?;
    let y = divide(x, 2)?;
    return Ok(y);
}

let calc_result = calculate();
println(f"calculate() returned: {calc_result}");

// Hash maps
let scores = {"alice": 95, "bob": 87, "charlie": 92};
println(f"scores: {scores}");

let alice_key = "alice";
let alice_score = scores[alice_key];
println(f"alice's score: {alice_score}");
println(f"all keys: {keys(scores)}");

if has_key(scores, "bob") {
    let bob_key = "bob";
    let bob_score = scores[bob_key];
    println(f"bob is in scores with {bob_score} points");
}

let updated = set(scores, "dave", 88);
println(f"after adding dave: {updated}");
