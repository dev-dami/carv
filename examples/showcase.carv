// Advanced Carv features - classes, result types, maps, string interpolation, ownership

// String interpolation
let name = "Carv";
let version = "0.3.0";
println(f"Welcome to {name} v{version}!");

let x = 42;
let y = 3.14;
println(f"The answer is {x} and pi is approximately {y}");

// Expressions in interpolation
let a = 10;
let b = 5;
println(f"{a} + {b} = {a + b}");
println(f"{a} * {b} = {a * b}");

// Classes
class Counter {
    value: int = 0

    fn increment() {
        self.value = self.value + 1;
    }

    fn get() -> int {
        return self.value;
    }
}

let counter = new Counter;
counter.increment();
counter.increment();
println(f"counter value: {counter.get()}");

// Result types and pattern matching
fn divide(a: int, b: int) {
    if b == 0 {
        return Err("division by zero");
    }
    return Ok(a / b);
}

let result = divide(10, 2);
match result {
    Ok(v) => println(f"10 / 2 = {v}"),
    Err(e) => println(f"error: {e}"),
};

let bad = divide(10, 0);
match bad {
    Ok(v) => println(f"result: {v}"),
    Err(e) => println(f"caught error: {e}"),
};

// Try operator
fn calculate() {
    let x = divide(100, 5)?;
    let y = divide(x, 2)?;
    return Ok(y);
}

let calc_result = calculate();
println(f"calculate() returned: {calc_result}");

// Hash maps
let scores = {"alice": 95, "bob": 87, "charlie": 92};
println(f"scores: {scores}");

let alice_key = "alice";
let alice_score = scores[alice_key];
println(f"alice's score: {alice_score}");
println(f"all keys: {keys(scores)}");

if has_key(scores, "bob") {
    let bob_key = "bob";
    let bob_score = scores[bob_key];
    println(f"bob is in scores with {bob_score} points");
}

let updated = set(scores, "dave", 88);
println(f"after adding dave: {updated}");

// Ownership - move semantics
let greeting = "hello";
let moved = greeting;     // greeting moved to moved
// print(greeting);       // ERROR: use of moved value 'greeting'
println(f"moved: {moved}");

// clone() for explicit deep copy
let original = "world";
let copy = original.clone();
println(f"original: {original}, copy: {copy}");  // both valid

// Borrowing
fn print_len(s: &string) -> int {
    return len(s);
}

let msg = "borrowing works!";
let n = print_len(&msg);
println(f"'{msg}' has length {n}");  // msg still valid after borrow

// Interfaces - dynamic dispatch via vtables
interface Greeter {
    fn greet(&self) -> string;
}

class English {
    name: string = "English"

    fn greet(&self) -> string {
        return "Hello!";
    }
}

class Spanish {
    name: string = "Spanish"

    fn greet(&self) -> string {
        return "Hola!";
    }
}

impl Greeter for English {
    fn greet(&self) -> string {
        return "Hello!";
    }
}

impl Greeter for Spanish {
    fn greet(&self) -> string {
        return "Hola!";
    }
}

fn say_greeting(g: &Greeter) {
    println(g.greet());
}

let e = new English;
let s = new Spanish;
say_greeting(&e as &Greeter);  // prints: Hello!
say_greeting(&s as &Greeter);  // prints: Hola!
