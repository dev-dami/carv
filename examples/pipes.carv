// Pipe operator (|>) - functional data flow

// Basic pipe usage
fn double(x: int) -> int {
    return x * 2;
}

fn add_ten(x: int) -> int {
    return x + 10;
}

fn square(x: int) -> int {
    return x * x;
}

// Chain transformations with pipes
let result = 5 |> double |> add_ten |> square;
println(f"5 |> double |> add_ten |> square = {result}");

// Step by step:
// 5 -> double -> 10 -> add_ten -> 20 -> square -> 400

// Pipes with string transformations
fn exclaim(s: string) -> string {
    return s + "!";
}

let greeting = "hello" |> exclaim |> exclaim;
println(f"Greeting: {greeting}");

// Pipes with print (void return)
5 |> double |> double |> print;
println("");

// Complex pipeline
fn increment(x: int) -> int {
    return x + 1;
}

fn halve(x: int) -> int {
    return x / 2;
}

let pipeline = 100
    |> halve
    |> halve
    |> increment
    |> double;

println(f"100 |> halve |> halve |> increment |> double = {pipeline}");

// Pipes make nested calls readable
// Without pipes: square(add_ten(double(5)))
// With pipes:    5 |> double |> add_ten |> square
println("Pipes transform: f(g(h(x))) into: x |> h |> g |> f");
