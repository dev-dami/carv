// Carv Parser - Written in Carv
// Proof of concept for self-hosting
// Uses Pratt parsing (recursive descent with operator precedence)
// AST nodes are represented as maps for simplicity

// Token types - must match lexer.carv
const TOKEN_ILLEGAL = 0;
const TOKEN_EOF = 1;
const TOKEN_IDENT = 2;
const TOKEN_INT = 3;
const TOKEN_FLOAT = 4;
const TOKEN_STRING = 5;
const TOKEN_CHAR = 6;

const TOKEN_PLUS = 10;
const TOKEN_MINUS = 11;
const TOKEN_STAR = 12;
const TOKEN_SLASH = 13;
const TOKEN_PERCENT = 14;
const TOKEN_BANG = 15;
const TOKEN_ASSIGN = 16;
const TOKEN_EQ = 17;
const TOKEN_NE = 18;
const TOKEN_LT = 19;
const TOKEN_LE = 20;
const TOKEN_GT = 21;
const TOKEN_GE = 22;
const TOKEN_AND = 23;
const TOKEN_OR = 24;
const TOKEN_AMPERSAND = 25;
const TOKEN_VBAR = 26;
const TOKEN_CARET = 27;
const TOKEN_TILDE = 28;
const TOKEN_QUESTION = 29;

const TOKEN_LPAREN = 30;
const TOKEN_RPAREN = 31;
const TOKEN_LBRACE = 32;
const TOKEN_RBRACE = 33;
const TOKEN_LBRACKET = 34;
const TOKEN_RBRACKET = 35;
const TOKEN_COMMA = 36;
const TOKEN_DOT = 37;
const TOKEN_COLON = 38;
const TOKEN_SEMI = 39;
const TOKEN_ARROW = 40;
const TOKEN_FAT_ARROW = 41;
const TOKEN_PIPE = 42;

const TOKEN_FN = 50;
const TOKEN_LET = 51;
const TOKEN_CONST = 52;
const TOKEN_IF = 53;
const TOKEN_ELSE = 54;
const TOKEN_MATCH = 55;
const TOKEN_FOR = 56;
const TOKEN_WHILE = 57;
const TOKEN_BREAK = 59;
const TOKEN_CONTINUE = 60;
const TOKEN_RETURN = 61;
const TOKEN_CLASS = 62;
const TOKEN_PUB = 63;
const TOKEN_NEW = 64;
const TOKEN_SELF = 65;
const TOKEN_TRUE = 66;
const TOKEN_FALSE = 67;
const TOKEN_NIL = 68;
const TOKEN_OK = 69;
const TOKEN_ERR = 70;
const TOKEN_REQUIRE = 71;
const TOKEN_FROM = 72;
const TOKEN_IN = 73;
const TOKEN_MUT = 74;

const TOKEN_INT_TYPE = 80;
const TOKEN_FLOAT_TYPE = 81;
const TOKEN_BOOL_TYPE = 82;
const TOKEN_STRING_TYPE = 83;
const TOKEN_CHAR_TYPE = 84;
const TOKEN_VOID_TYPE = 85;
const TOKEN_ANY_TYPE = 86;

// Precedence levels
const PREC_LOWEST = 1;
const PREC_PIPE = 2;
const PREC_ASSIGN = 3;
const PREC_OR = 4;
const PREC_AND = 5;
const PREC_EQUALS = 6;
const PREC_LESSGREATER = 7;
const PREC_BITOR = 8;
const PREC_BITXOR = 9;
const PREC_BITAND = 10;
const PREC_SUM = 11;
const PREC_PRODUCT = 12;
const PREC_PREFIX = 13;
const PREC_CALL = 14;
const PREC_INDEX = 15;
const PREC_POSTFIX = 16;

// Token precedence map
let precedences = {
    42: 2, 16: 3, 24: 4, 23: 5, 17: 6, 18: 6,
    19: 7, 20: 7, 21: 7, 22: 7, 26: 8, 27: 9, 25: 10,
    10: 11, 11: 11, 12: 12, 13: 12, 14: 12,
    30: 14, 34: 15, 37: 15, 29: 16
};

// ============== LEXER ==============
let keywords = {
    "fn": TOKEN_FN, "let": TOKEN_LET, "const": TOKEN_CONST,
    "if": TOKEN_IF, "else": TOKEN_ELSE, "match": TOKEN_MATCH,
    "for": TOKEN_FOR, "while": TOKEN_WHILE, "break": TOKEN_BREAK,
    "continue": TOKEN_CONTINUE, "return": TOKEN_RETURN,
    "class": TOKEN_CLASS, "pub": TOKEN_PUB, "new": TOKEN_NEW,
    "self": TOKEN_SELF, "true": TOKEN_TRUE, "false": TOKEN_FALSE,
    "nil": TOKEN_NIL, "Ok": TOKEN_OK, "Err": TOKEN_ERR,
    "require": TOKEN_REQUIRE, "from": TOKEN_FROM, "in": TOKEN_IN,
    "mut": TOKEN_MUT, "int": TOKEN_INT_TYPE, "float": TOKEN_FLOAT_TYPE,
    "bool": TOKEN_BOOL_TYPE, "string": TOKEN_STRING_TYPE,
    "char": TOKEN_CHAR_TYPE, "void": TOKEN_VOID_TYPE, "any": TOKEN_ANY_TYPE
};

fn is_letter(ch: char) -> bool {
    let c = ord(ch);
    return (c >= 65 && c <= 90) || (c >= 97 && c <= 122) || c == 95;
}

fn is_digit(ch: char) -> bool {
    let c = ord(ch);
    return c >= 48 && c <= 57;
}

fn is_whitespace(ch: char) -> bool {
    return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r';
}

fn lookup_ident(ident: string) -> int {
    if has_key(keywords, ident) {
        return keywords[ident];
    }
    return TOKEN_IDENT;
}

fn make_token(tok_type: int, literal: string, line: int, column: int) {
    return {"type": tok_type, "literal": literal, "line": line, "col": column};
}

fn tokenize(input: string) {
    let tokens = [];
    let i = 0;
    let line = 1;
    let col = 1;
    let input_len = len(input);
    
    while i < input_len {
        let ch = char_at(input, i);
        let tok_line = line;
        let tok_col = col;
        
        if is_whitespace(ch) {
            if ch == '\n' {
                line = line + 1;
                col = 0;
            }
            i = i + 1;
            col = col + 1;
            continue;
        }
        
        if ch == '/' && i + 1 < input_len && char_at(input, i + 1) == '/' {
            while i < input_len && char_at(input, i) != '\n' {
                i = i + 1;
            }
            continue;
        }
        
        if is_letter(ch) {
            let start = i;
            while i < input_len && (is_letter(char_at(input, i)) || is_digit(char_at(input, i))) {
                i = i + 1;
                col = col + 1;
            }
            let ident = substr(input, start, i);
            tokens = push(tokens, make_token(lookup_ident(ident), ident, tok_line, tok_col));
            continue;
        }
        
        if is_digit(ch) {
            let start = i;
            let is_float = false;
            while i < input_len && is_digit(char_at(input, i)) {
                i = i + 1;
                col = col + 1;
            }
            if i < input_len && char_at(input, i) == '.' && i + 1 < input_len && is_digit(char_at(input, i + 1)) {
                is_float = true;
                i = i + 1;
                col = col + 1;
                while i < input_len && is_digit(char_at(input, i)) {
                    i = i + 1;
                    col = col + 1;
                }
            }
            let literal = substr(input, start, i);
            if is_float {
                tokens = push(tokens, make_token(TOKEN_FLOAT, literal, tok_line, tok_col));
            } else {
                tokens = push(tokens, make_token(TOKEN_INT, literal, tok_line, tok_col));
            }
            continue;
        }
        
        if ch == '"' {
            i = i + 1;
            col = col + 1;
            let start = i;
            while i < input_len && char_at(input, i) != '"' {
                if char_at(input, i) == '\\' && i + 1 < input_len {
                    i = i + 2;
                    col = col + 2;
                } else {
                    i = i + 1;
                    col = col + 1;
                }
            }
            let str_val = substr(input, start, i);
            i = i + 1;
            col = col + 1;
            tokens = push(tokens, make_token(TOKEN_STRING, str_val, tok_line, tok_col));
            continue;
        }
        
        if ch == '\'' {
            i = i + 1;
            col = col + 1;
            let char_val = "";
            if i < input_len {
                if char_at(input, i) == '\\' && i + 1 < input_len {
                    let esc = char_at(input, i + 1);
                    if esc == 'n' { char_val = "\n"; }
                    else { if esc == 't' { char_val = "\t"; }
                    else { if esc == 'r' { char_val = "\r"; }
                    else { char_val = str(esc); } } }
                    i = i + 2;
                    col = col + 2;
                } else {
                    char_val = str(char_at(input, i));
                    i = i + 1;
                    col = col + 1;
                }
            }
            if i < input_len && char_at(input, i) == '\'' {
                i = i + 1;
                col = col + 1;
            }
            tokens = push(tokens, make_token(TOKEN_CHAR, char_val, tok_line, tok_col));
            continue;
        }
        
        let peek = '\0';
        if i + 1 < input_len { peek = char_at(input, i + 1); }
        
        if ch == '-' && peek == '>' {
            tokens = push(tokens, make_token(TOKEN_ARROW, "->", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        if ch == '!' && peek == '=' {
            tokens = push(tokens, make_token(TOKEN_NE, "!=", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        if ch == '=' && peek == '=' {
            tokens = push(tokens, make_token(TOKEN_EQ, "==", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        if ch == '=' && peek == '>' {
            tokens = push(tokens, make_token(TOKEN_FAT_ARROW, "=>", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        if ch == '<' && peek == '=' {
            tokens = push(tokens, make_token(TOKEN_LE, "<=", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        if ch == '>' && peek == '=' {
            tokens = push(tokens, make_token(TOKEN_GE, ">=", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        if ch == '&' && peek == '&' {
            tokens = push(tokens, make_token(TOKEN_AND, "&&", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        if ch == '|' && peek == '|' {
            tokens = push(tokens, make_token(TOKEN_OR, "||", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        if ch == '|' && peek == '>' {
            tokens = push(tokens, make_token(TOKEN_PIPE, "|>", tok_line, tok_col));
            i = i + 2; col = col + 2; continue;
        }
        
        let tok_type = TOKEN_ILLEGAL;
        if ch == '+' { tok_type = TOKEN_PLUS; }
        if ch == '-' { tok_type = TOKEN_MINUS; }
        if ch == '*' { tok_type = TOKEN_STAR; }
        if ch == '/' { tok_type = TOKEN_SLASH; }
        if ch == '%' { tok_type = TOKEN_PERCENT; }
        if ch == '!' { tok_type = TOKEN_BANG; }
        if ch == '=' { tok_type = TOKEN_ASSIGN; }
        if ch == '<' { tok_type = TOKEN_LT; }
        if ch == '>' { tok_type = TOKEN_GT; }
        if ch == '&' { tok_type = TOKEN_AMPERSAND; }
        if ch == '|' { tok_type = TOKEN_VBAR; }
        if ch == '^' { tok_type = TOKEN_CARET; }
        if ch == '~' { tok_type = TOKEN_TILDE; }
        if ch == '?' { tok_type = TOKEN_QUESTION; }
        if ch == '(' { tok_type = TOKEN_LPAREN; }
        if ch == ')' { tok_type = TOKEN_RPAREN; }
        if ch == '{' { tok_type = TOKEN_LBRACE; }
        if ch == '}' { tok_type = TOKEN_RBRACE; }
        if ch == '[' { tok_type = TOKEN_LBRACKET; }
        if ch == ']' { tok_type = TOKEN_RBRACKET; }
        if ch == ',' { tok_type = TOKEN_COMMA; }
        if ch == '.' { tok_type = TOKEN_DOT; }
        if ch == ':' { tok_type = TOKEN_COLON; }
        if ch == ';' { tok_type = TOKEN_SEMI; }
        
        tokens = push(tokens, make_token(tok_type, str(ch), tok_line, tok_col));
        i = i + 1;
        col = col + 1;
    }
    
    tokens = push(tokens, make_token(TOKEN_EOF, "", line, col));
    return tokens;
}

// ============== PARSER STATE ==============
mut g_tokens = [];
mut g_pos = 0;
mut g_errors = [];

fn init_parser(tokens) {
    g_tokens = tokens;
    g_pos = 0;
    g_errors = [];
}

fn cur_tok() {
    if g_pos < len(g_tokens) {
        return g_tokens[g_pos];
    }
    return make_token(TOKEN_EOF, "", 0, 0);
}

fn peek_tok() {
    if g_pos + 1 < len(g_tokens) {
        return g_tokens[g_pos + 1];
    }
    return make_token(TOKEN_EOF, "", 0, 0);
}

fn advance() {
    if g_pos < len(g_tokens) {
        g_pos = g_pos + 1;
    }
}

fn cur_is(t: int) -> bool {
    return cur_tok()["type"] == t;
}

fn peek_is(t: int) -> bool {
    return peek_tok()["type"] == t;
}

fn expect(t: int) -> bool {
    if peek_is(t) {
        advance();
        return true;
    }
    let tok = peek_tok();
    let tok_line = tok["line"];
    let tok_col = tok["col"];
    let tok_type = tok["type"];
    g_errors = push(g_errors, f"line {tok_line}:{tok_col}: expected {t}, got {tok_type}");
    return false;
}

fn cur_prec() -> int {
    let t = cur_tok()["type"];
    if has_key(precedences, t) {
        return precedences[t];
    }
    return PREC_LOWEST;
}

fn peek_prec() -> int {
    let t = peek_tok()["type"];
    if has_key(precedences, t) {
        return precedences[t];
    }
    return PREC_LOWEST;
}

fn add_err(msg: string) {
    g_errors = push(g_errors, msg);
}

fn node(kind: string, tok) {
    return {"kind": kind, "line": tok["line"], "col": tok["col"], "literal": tok["literal"]};
}

// ============== TYPE PARSING ==============
fn parse_type() {
    let t = cur_tok()["type"];
    
    if t == TOKEN_INT_TYPE { return {"kind": "basic", "name": "int"}; }
    if t == TOKEN_FLOAT_TYPE { return {"kind": "basic", "name": "float"}; }
    if t == TOKEN_BOOL_TYPE { return {"kind": "basic", "name": "bool"}; }
    if t == TOKEN_STRING_TYPE { return {"kind": "basic", "name": "string"}; }
    if t == TOKEN_CHAR_TYPE { return {"kind": "basic", "name": "char"}; }
    if t == TOKEN_VOID_TYPE { return {"kind": "basic", "name": "void"}; }
    if t == TOKEN_ANY_TYPE { return {"kind": "basic", "name": "any"}; }
    if t == TOKEN_IDENT { return {"kind": "named", "name": cur_tok()["literal"]}; }
    // TODO: array types would need forward reference to parse_expr
    return nil;
}

// ============== SIMPLE EXPRESSION PARSING ==============
// To avoid forward references, we use a table-driven approach

fn parse_ident() {
    let n = node("ident", cur_tok());
    n["name"] = cur_tok()["literal"];
    return n;
}

fn parse_int_lit() {
    let n = node("int", cur_tok());
    n["value"] = parse_int(cur_tok()["literal"]);
    return n;
}

fn parse_float_lit() {
    let n = node("float", cur_tok());
    n["value"] = parse_float(cur_tok()["literal"]);
    return n;
}

fn parse_string_lit() {
    let n = node("string", cur_tok());
    n["value"] = cur_tok()["literal"];
    return n;
}

fn parse_bool_lit() {
    let n = node("bool", cur_tok());
    n["value"] = cur_is(TOKEN_TRUE);
    return n;
}

fn parse_nil_lit() {
    return node("nil", cur_tok());
}

fn parse_self_expr() {
    let n = node("ident", cur_tok());
    n["name"] = "self";
    return n;
}

// ============== MAIN PARSING FUNCTION ==============
// This single function handles all parsing to avoid forward references

fn parse(mode: string) {
    // mode: "expr", "stmt", "block", "program", "prefix", "params", "expr_list"
    
    if mode == "prefix" {
        let t = cur_tok()["type"];
        
        if t == TOKEN_IDENT { return parse_ident(); }
        if t == TOKEN_INT { return parse_int_lit(); }
        if t == TOKEN_FLOAT { return parse_float_lit(); }
        if t == TOKEN_STRING { return parse_string_lit(); }
        if t == TOKEN_TRUE || t == TOKEN_FALSE { return parse_bool_lit(); }
        if t == TOKEN_NIL { return parse_nil_lit(); }
        if t == TOKEN_SELF { return parse_self_expr(); }
        
        // Prefix operators
        if t == TOKEN_BANG || t == TOKEN_MINUS || t == TOKEN_TILDE {
            let n = node("prefix", cur_tok());
            n["op"] = cur_tok()["literal"];
            advance();
            n["right"] = parse("expr_prec_13");
            return n;
        }
        
        // Grouped expression
        if t == TOKEN_LPAREN {
            advance();
            let expr = parse("expr");
            if !expect(TOKEN_RPAREN) { return nil; }
            return expr;
        }
        
        // Array literal
        if t == TOKEN_LBRACKET {
            let n = node("array", cur_tok());
            n["elements"] = parse("expr_list_bracket");
            return n;
        }
        
        // Map literal
        if t == TOKEN_LBRACE {
            let n = node("map", cur_tok());
            let pairs = [];
            
            if peek_is(TOKEN_RBRACE) {
                advance();
                n["pairs"] = pairs;
                return n;
            }
            
            advance();
            let key = parse("expr");
            if !expect(TOKEN_COLON) { return nil; }
            advance();
            let val = parse("expr");
            pairs = push(pairs, {"key": key, "value": val});
            
            while peek_is(TOKEN_COMMA) {
                advance();
                advance();
                let key = parse("expr");
                if !expect(TOKEN_COLON) { return nil; }
                advance();
                let val = parse("expr");
                pairs = push(pairs, {"key": key, "value": val});
            }
            
            if !expect(TOKEN_RBRACE) { return nil; }
            n["pairs"] = pairs;
            return n;
        }
        
        // If expression
        if t == TOKEN_IF {
            let n = node("if", cur_tok());
            advance();
            n["cond"] = parse("expr");
            if !expect(TOKEN_LBRACE) { return nil; }
            n["then"] = parse("block");
            if peek_is(TOKEN_ELSE) {
                advance();
                if !expect(TOKEN_LBRACE) { return nil; }
                n["else"] = parse("block");
            }
            return n;
        }
        
        // Function literal
        if t == TOKEN_FN {
            let n = node("fn", cur_tok());
            if peek_is(TOKEN_IDENT) {
                advance();
                n["name"] = cur_tok()["literal"];
            }
            if !expect(TOKEN_LPAREN) { return nil; }
            n["params"] = parse("params");
            if peek_is(TOKEN_ARROW) {
                advance();
                advance();
                n["ret_type"] = parse_type();
            }
            if !expect(TOKEN_LBRACE) { return nil; }
            n["body"] = parse("block");
            return n;
        }
        
        // New expression
        if t == TOKEN_NEW {
            let n = node("new", cur_tok());
            advance();
            n["type"] = parse_type();
            return n;
        }
        
        // Ok/Err expressions
        if t == TOKEN_OK {
            let n = node("ok", cur_tok());
            if !expect(TOKEN_LPAREN) { return nil; }
            advance();
            n["value"] = parse("expr");
            if !expect(TOKEN_RPAREN) { return nil; }
            return n;
        }
        if t == TOKEN_ERR {
            let n = node("err", cur_tok());
            if !expect(TOKEN_LPAREN) { return nil; }
            advance();
            n["value"] = parse("expr");
            if !expect(TOKEN_RPAREN) { return nil; }
            return n;
        }
        
        // Match expression
        if t == TOKEN_MATCH {
            let n = node("match", cur_tok());
            advance();
            n["value"] = parse("expr");
            if !expect(TOKEN_LBRACE) { return nil; }
            let arms = [];
            advance();
            while !cur_is(TOKEN_RBRACE) && !cur_is(TOKEN_EOF) {
                let arm = {};
                arm["pattern"] = parse("expr");
                if !expect(TOKEN_FAT_ARROW) { return nil; }
                advance();
                if cur_is(TOKEN_LBRACE) {
                    arm["body"] = parse("block");
                } else {
                    arm["body"] = parse("expr");
                }
                if peek_is(TOKEN_COMMA) { advance(); }
                arms = push(arms, arm);
                advance();
            }
            n["arms"] = arms;
            return n;
        }
        
        let tok = cur_tok();
        let tok_line = tok["line"];
        let tok_col = tok["col"];
        add_err(f"line {tok_line}:{tok_col}: no prefix parse for token {t}");
        return nil;
    }
    
    if mode == "expr" || mode == "expr_prec_1" {
        return parse("expr_prec:1");
    }
    
    if mode == "expr_prec_13" {
        return parse("expr_prec:13");
    }
    
    // Expression with precedence
    if starts_with(mode, "expr_prec:") {
        let prec_str = substr(mode, 10, len(mode));
        let prec = parse_int(prec_str);
        
        let left = parse("prefix");
        if left == nil { return nil; }
        
        while !peek_is(TOKEN_SEMI) && prec < peek_prec() {
            let t = peek_tok()["type"];
            advance();
            
            // Infix operators
            if t == TOKEN_PLUS || t == TOKEN_MINUS || t == TOKEN_STAR || t == TOKEN_SLASH ||
               t == TOKEN_PERCENT || t == TOKEN_EQ || t == TOKEN_NE || t == TOKEN_LT ||
               t == TOKEN_LE || t == TOKEN_GT || t == TOKEN_GE || t == TOKEN_AND ||
               t == TOKEN_OR || t == TOKEN_AMPERSAND || t == TOKEN_VBAR || t == TOKEN_CARET {
                let n = node("infix", cur_tok());
                n["op"] = cur_tok()["literal"];
                n["left"] = left;
                let cur_p = cur_prec();
                advance();
                n["right"] = parse(f"expr_prec:{cur_p}");
                left = n;
                continue;
            }
            
            // Call expression
            if t == TOKEN_LPAREN {
                let n = node("call", cur_tok());
                n["fn"] = left;
                n["args"] = parse("expr_list_paren");
                left = n;
                continue;
            }
            
            // Index expression
            if t == TOKEN_LBRACKET {
                let n = node("index", cur_tok());
                n["left"] = left;
                advance();
                n["index"] = parse("expr");
                if !expect(TOKEN_RBRACKET) { return nil; }
                left = n;
                continue;
            }
            
            // Member expression
            if t == TOKEN_DOT {
                let n = node("member", cur_tok());
                n["object"] = left;
                if !expect(TOKEN_IDENT) { return nil; }
                n["member"] = cur_tok()["literal"];
                left = n;
                continue;
            }
            
            // Assignment
            if t == TOKEN_ASSIGN {
                let n = node("assign", cur_tok());
                n["op"] = cur_tok()["literal"];
                n["left"] = left;
                advance();
                n["right"] = parse("expr");
                left = n;
                continue;
            }
            
            // Pipe expression
            if t == TOKEN_PIPE {
                let n = node("pipe", cur_tok());
                n["left"] = left;
                let cur_p = cur_prec();
                advance();
                n["right"] = parse(f"expr_prec:{cur_p}");
                left = n;
                continue;
            }
            
            // Try expression (?)
            if t == TOKEN_QUESTION {
                let n = node("try", cur_tok());
                n["value"] = left;
                left = n;
                continue;
            }
        }
        
        return left;
    }
    
    if mode == "expr_list_paren" {
        let list = [];
        if peek_is(TOKEN_RPAREN) {
            advance();
            return list;
        }
        advance();
        list = push(list, parse("expr"));
        while peek_is(TOKEN_COMMA) {
            advance();
            advance();
            list = push(list, parse("expr"));
        }
        if !expect(TOKEN_RPAREN) { return nil; }
        return list;
    }
    
    if mode == "expr_list_bracket" {
        let list = [];
        if peek_is(TOKEN_RBRACKET) {
            advance();
            return list;
        }
        advance();
        list = push(list, parse("expr"));
        while peek_is(TOKEN_COMMA) {
            advance();
            advance();
            list = push(list, parse("expr"));
        }
        if !expect(TOKEN_RBRACKET) { return nil; }
        return list;
    }
    
    if mode == "params" {
        let params = [];
        if peek_is(TOKEN_RPAREN) {
            advance();
            return params;
        }
        advance();
        
        // Parse first param
        let param = {"mutable": false};
        if cur_is(TOKEN_MUT) {
            param["mutable"] = true;
            advance();
        }
        if cur_is(TOKEN_IDENT) {
            param["name"] = cur_tok()["literal"];
            if peek_is(TOKEN_COLON) {
                advance();
                advance();
                param["type"] = parse_type();
            }
            params = push(params, param);
        }
        
        while peek_is(TOKEN_COMMA) {
            advance();
            advance();
            let param = {"mutable": false};
            if cur_is(TOKEN_MUT) {
                param["mutable"] = true;
                advance();
            }
            if cur_is(TOKEN_IDENT) {
                param["name"] = cur_tok()["literal"];
                if peek_is(TOKEN_COLON) {
                    advance();
                    advance();
                    param["type"] = parse_type();
                }
                params = push(params, param);
            }
        }
        
        if !expect(TOKEN_RPAREN) { return nil; }
        return params;
    }
    
    if mode == "block" {
        let n = node("block", cur_tok());
        let stmts = [];
        advance();
        while !cur_is(TOKEN_RBRACE) && !cur_is(TOKEN_EOF) {
            let s = parse("stmt");
            if s != nil { stmts = push(stmts, s); }
            advance();
        }
        n["stmts"] = stmts;
        return n;
    }
    
    if mode == "stmt" {
        let t = cur_tok()["type"];
        
        // Let statement
        if t == TOKEN_LET || t == TOKEN_MUT {
            let n = node("let", cur_tok());
            n["mutable"] = cur_is(TOKEN_MUT);
            if !expect(TOKEN_IDENT) { return nil; }
            n["name"] = cur_tok()["literal"];
            if peek_is(TOKEN_COLON) {
                advance();
                advance();
                n["type"] = parse_type();
            }
            if !expect(TOKEN_ASSIGN) { return nil; }
            advance();
            n["value"] = parse("expr");
            if !expect(TOKEN_SEMI) { return nil; }
            return n;
        }
        
        // Const statement
        if t == TOKEN_CONST {
            let n = node("const", cur_tok());
            if !expect(TOKEN_IDENT) { return nil; }
            n["name"] = cur_tok()["literal"];
            if peek_is(TOKEN_COLON) {
                advance();
                advance();
                n["type"] = parse_type();
            }
            if !expect(TOKEN_ASSIGN) { return nil; }
            advance();
            n["value"] = parse("expr");
            if !expect(TOKEN_SEMI) { return nil; }
            return n;
        }
        
        // Return statement
        if t == TOKEN_RETURN {
            let n = node("return", cur_tok());
            if peek_is(TOKEN_SEMI) {
                advance();
                return n;
            }
            advance();
            n["value"] = parse("expr");
            if !expect(TOKEN_SEMI) { return nil; }
            return n;
        }
        
        // Function statement
        if t == TOKEN_FN {
            let n = node("fn_stmt", cur_tok());
            if !expect(TOKEN_IDENT) { return nil; }
            n["name"] = cur_tok()["literal"];
            if !expect(TOKEN_LPAREN) { return nil; }
            n["params"] = parse("params");
            if peek_is(TOKEN_ARROW) {
                advance();
                advance();
                n["ret_type"] = parse_type();
            }
            if !expect(TOKEN_LBRACE) { return nil; }
            n["body"] = parse("block");
            return n;
        }
        
        // Class statement
        if t == TOKEN_CLASS {
            let n = node("class", cur_tok());
            if !expect(TOKEN_IDENT) { return nil; }
            n["name"] = cur_tok()["literal"];
            if !expect(TOKEN_LBRACE) { return nil; }
            let fields = [];
            let methods = [];
            advance();
            while !cur_is(TOKEN_RBRACE) && !cur_is(TOKEN_EOF) {
                if cur_is(TOKEN_FN) {
                    let m = {};
                    if !expect(TOKEN_IDENT) { return nil; }
                    m["name"] = cur_tok()["literal"];
                    if !expect(TOKEN_LPAREN) { return nil; }
                    m["params"] = parse("params");
                    if peek_is(TOKEN_ARROW) {
                        advance();
                        advance();
                        m["ret_type"] = parse_type();
                    }
                    if !expect(TOKEN_LBRACE) { return nil; }
                    m["body"] = parse("block");
                    methods = push(methods, m);
                } else {
                    if cur_is(TOKEN_IDENT) {
                        let f = {"name": cur_tok()["literal"]};
                        if !expect(TOKEN_COLON) { return nil; }
                        advance();
                        f["type"] = parse_type();
                        if peek_is(TOKEN_ASSIGN) {
                            advance();
                            advance();
                            f["default"] = parse("expr");
                        }
                        fields = push(fields, f);
                    }
                }
                advance();
            }
            n["fields"] = fields;
            n["methods"] = methods;
            return n;
        }
        
        // For statement
        if t == TOKEN_FOR {
            let start = cur_tok();
            advance();
            
            if cur_is(TOKEN_LBRACE) {
                let n = node("loop", start);
                n["body"] = parse("block");
                return n;
            }
            
            if cur_is(TOKEN_IDENT) && peek_is(TOKEN_IN) {
                let n = node("for_in", start);
                n["var"] = cur_tok()["literal"];
                advance();
                advance();
                n["iter"] = parse("expr");
                if !expect(TOKEN_LBRACE) { return nil; }
                n["body"] = parse("block");
                return n;
            }
            
            let n = node("for", start);
            if !cur_is(TOKEN_LPAREN) {
                add_err("expected ( in for loop");
                return nil;
            }
            advance();
            if !cur_is(TOKEN_SEMI) {
                if cur_is(TOKEN_LET) || cur_is(TOKEN_MUT) {
                    n["init"] = parse("stmt");
                } else {
                    let expr_stmt = node("expr_stmt", cur_tok());
                    expr_stmt["expr"] = parse("expr");
                    if !expect(TOKEN_SEMI) { return nil; }
                    n["init"] = expr_stmt;
                }
            }
            if cur_is(TOKEN_SEMI) { advance(); }
            if !cur_is(TOKEN_SEMI) {
                n["cond"] = parse("expr");
            }
            if !expect(TOKEN_SEMI) { return nil; }
            advance();
            if !cur_is(TOKEN_RPAREN) {
                n["post"] = parse("expr");
            }
            if !expect(TOKEN_RPAREN) { return nil; }
            if !expect(TOKEN_LBRACE) { return nil; }
            n["body"] = parse("block");
            return n;
        }
        
        // While statement
        if t == TOKEN_WHILE {
            let n = node("while", cur_tok());
            advance();
            n["cond"] = parse("expr");
            if !expect(TOKEN_LBRACE) { return nil; }
            n["body"] = parse("block");
            return n;
        }
        
        // Break/Continue
        if t == TOKEN_BREAK {
            let n = node("break", cur_tok());
            if !expect(TOKEN_SEMI) { return nil; }
            return n;
        }
        if t == TOKEN_CONTINUE {
            let n = node("continue", cur_tok());
            if !expect(TOKEN_SEMI) { return nil; }
            return n;
        }
        
        // Require statement
        if t == TOKEN_REQUIRE {
            let n = node("require", cur_tok());
            if peek_is(TOKEN_STRING) {
                advance();
                n["path"] = cur_tok()["literal"];
                if !expect(TOKEN_SEMI) { return nil; }
                return n;
            }
            if peek_is(TOKEN_LBRACE) {
                advance();
                let names = [];
                if !peek_is(TOKEN_RBRACE) {
                    if !expect(TOKEN_IDENT) { return nil; }
                    names = push(names, cur_tok()["literal"]);
                    while peek_is(TOKEN_COMMA) {
                        advance();
                        if !expect(TOKEN_IDENT) { return nil; }
                        names = push(names, cur_tok()["literal"]);
                    }
                }
                if !expect(TOKEN_RBRACE) { return nil; }
                if !expect(TOKEN_FROM) { return nil; }
                if !expect(TOKEN_STRING) { return nil; }
                n["path"] = cur_tok()["literal"];
                n["names"] = names;
                if !expect(TOKEN_SEMI) { return nil; }
                return n;
            }
            if peek_is(TOKEN_STAR) {
                advance();
                if !expect(TOKEN_FROM) { return nil; }
                if !expect(TOKEN_STRING) { return nil; }
                n["path"] = cur_tok()["literal"];
                n["all"] = true;
                if !expect(TOKEN_SEMI) { return nil; }
                return n;
            }
            add_err("expected string, { or * after require");
            return nil;
        }
        
        // Pub statement
        if t == TOKEN_PUB {
            advance();
            let s = parse("stmt");
            if s != nil { s["public"] = true; }
            return s;
        }
        
        // If statement (no semicolon needed)
        if t == TOKEN_IF {
            let n = node("if", cur_tok());
            advance();
            n["cond"] = parse("expr");
            if !expect(TOKEN_LBRACE) { return nil; }
            n["then"] = parse("block");
            if peek_is(TOKEN_ELSE) {
                advance();
                if !expect(TOKEN_LBRACE) { return nil; }
                n["else"] = parse("block");
            }
            return n;
        }
        
        // Match statement (no semicolon needed)
        if t == TOKEN_MATCH {
            let n = node("match", cur_tok());
            advance();
            n["value"] = parse("expr");
            if !expect(TOKEN_LBRACE) { return nil; }
            let arms = [];
            advance();
            while !cur_is(TOKEN_RBRACE) && !cur_is(TOKEN_EOF) {
                let arm = {};
                arm["pattern"] = parse("expr");
                if !expect(TOKEN_FAT_ARROW) { return nil; }
                advance();
                if cur_is(TOKEN_LBRACE) {
                    arm["body"] = parse("block");
                } else {
                    arm["body"] = parse("expr");
                }
                if peek_is(TOKEN_COMMA) { advance(); }
                arms = push(arms, arm);
                advance();
            }
            n["arms"] = arms;
            return n;
        }
        
        // Expression statement
        let n = node("expr_stmt", cur_tok());
        n["expr"] = parse("expr");
        if !expect(TOKEN_SEMI) { return nil; }
        return n;
    }
    
    if mode == "program" {
        let prog = node("program", cur_tok());
        let stmts = [];
        while !cur_is(TOKEN_EOF) {
            let s = parse("stmt");
            if s != nil { stmts = push(stmts, s); }
            advance();
        }
        prog["stmts"] = stmts;
        return prog;
    }
    
    return nil;
}

// ============== AST PRINTING ==============
fn print_indent(n: int) {
    let i = 0;
    while i < n {
        print(" ");
        i = i + 1;
    }
}

fn print_ast(n, indent: int) {
    if n == nil {
        print_indent(indent);
        println("nil");
        return;
    }
    
    print_indent(indent);
    let kind = n["kind"];
    
    if kind == "ident" {
        let name = n["name"];
        println(f"Ident: {name}");
        return;
    }
    if kind == "int" {
        let val = n["value"];
        println(f"Int: {val}");
        return;
    }
    if kind == "float" {
        let val = n["value"];
        println(f"Float: {val}");
        return;
    }
    if kind == "string" {
        let val = n["value"];
        println(f"String: \"{val}\"");
        return;
    }
    if kind == "bool" {
        let val = n["value"];
        println(f"Bool: {val}");
        return;
    }
    if kind == "nil" { println("Nil"); return; }
    
    if kind == "prefix" {
        let op = n["op"];
        println(f"Prefix: {op}");
        print_ast(n["right"], indent + 2);
        return;
    }
    
    if kind == "infix" {
        let op = n["op"];
        println(f"Infix: {op}");
        print_ast(n["left"], indent + 2);
        print_ast(n["right"], indent + 2);
        return;
    }
    
    if kind == "call" {
        println("Call:");
        print_indent(indent + 2);
        println("fn:");
        print_ast(n["fn"], indent + 4);
        print_indent(indent + 2);
        println("args:");
        for arg in n["args"] {
            print_ast(arg, indent + 4);
        }
        return;
    }
    
    if kind == "let" {
        let name = n["name"];
        println(f"Let: {name}");
        print_ast(n["value"], indent + 2);
        return;
    }
    
    if kind == "const" {
        let name = n["name"];
        println(f"Const: {name}");
        print_ast(n["value"], indent + 2);
        return;
    }
    
    if kind == "return" {
        println("Return:");
        if has_key(n, "value") {
            print_ast(n["value"], indent + 2);
        }
        return;
    }
    
    if kind == "fn_stmt" {
        let name = n["name"];
        let params = n["params"];
        let param_count = len(params);
        println(f"FnStmt: {name}");
        print_indent(indent + 2);
        println(f"params: {param_count}");
        print_indent(indent + 2);
        println("body:");
        print_ast(n["body"], indent + 4);
        return;
    }
    
    if kind == "block" {
        println("Block:");
        for s in n["stmts"] {
            print_ast(s, indent + 2);
        }
        return;
    }
    
    if kind == "if" {
        println("If:");
        print_indent(indent + 2);
        println("cond:");
        print_ast(n["cond"], indent + 4);
        print_indent(indent + 2);
        println("then:");
        print_ast(n["then"], indent + 4);
        if has_key(n, "else") {
            print_indent(indent + 2);
            println("else:");
            print_ast(n["else"], indent + 4);
        }
        return;
    }
    
    if kind == "for_in" {
        let var_name = n["var"];
        println(f"ForIn: {var_name}");
        print_indent(indent + 2);
        println("iter:");
        print_ast(n["iter"], indent + 4);
        print_indent(indent + 2);
        println("body:");
        print_ast(n["body"], indent + 4);
        return;
    }
    
    if kind == "expr_stmt" {
        println("ExprStmt:");
        print_ast(n["expr"], indent + 2);
        return;
    }
    
    if kind == "program" {
        println("Program:");
        for s in n["stmts"] {
            print_ast(s, indent + 2);
        }
        return;
    }
    
    if kind == "array" {
        println("Array:");
        for e in n["elements"] {
            print_ast(e, indent + 2);
        }
        return;
    }
    
    println(f"{kind}");
}

// ============== MAIN ==============
fn main() {
    println("=== Bootstrap Parser Starting ===");
    let program_args = args();
    
    if len(program_args) > 0 {
        let filename = program_args[0];
        let content = read_file(filename);
        
        println(f"Parsing {filename}...");
        println("---");
        
        let tokens = tokenize(content);
        init_parser(tokens);
        let ast = parse("program");
        
        if len(g_errors) > 0 {
            println("Parse errors:");
            for err in g_errors {
                println(f"  {err}");
            }
        } else {
            println("AST:");
            print_ast(ast, 0);
        }
    } else {
        let code = "fn add(a: int, b: int) -> int {
    return a + b;
}

let x = add(1, 2);
";
        
        println("Parsing demo code:");
        println("---");
        println(code);
        println("---");
        
        let tokens = tokenize(code);
        init_parser(tokens);
        let ast = parse("program");
        
        if len(g_errors) > 0 {
            println("Parse errors:");
            for err in g_errors {
                println(f"  {err}");
            }
        } else {
            println("AST:");
            print_ast(ast, 0);
        }
    }
}

main();
